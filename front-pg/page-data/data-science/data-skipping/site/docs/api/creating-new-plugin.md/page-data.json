{"componentChunkName":"component---src-templates-markdown-js","path":"/data-science/data-skipping/site/docs/api/creating-new-plugin.md","result":{"data":{"site":{"siteMetadata":{"title":"Operate First"}},"markdownRemark":{"id":"cb1a965a-65f6-5f2b-b3bd-62a8b8207828","html":"<!--\n -- Copyright 2021 IBM Corp.\n -- SPDX-License-Identifier: Apache-2.0\n -->\n<h1 id=\"using-the-extensible-api\" style=\"position:relative;\"><a href=\"#using-the-extensible-api\" aria-label=\"using the extensible api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using The Extensible API</h1>\n<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>!!! note\nThis page explains the Extensible Data Skipping framework API.<br>\nSee the <a href=\"../concepts/data-skipping.md\">Concepts</a> page for an explanation about the underlying concepts.<br>\nSee <a href=\"indexing.md#supported-plugins\">here</a> for the list of currently available plugins.</p>\n<p>Xskipper supports adding your index types and specifying your own data skipping logic\nin order to enjoy data skipping over UDFs and a variety of data types.</p>\n<p>The pluggability is split between two main areas:</p>\n<ul class=\"pf-c-list\">\n<li>\n<p><a href=\"#indexing-flow\">Indexing Flow</a></p>\n<ul class=\"pf-c-list\">\n<li>Interfaces for defining a new index - implementations of <a href=\"../scaladoc/1.2.3/io/xskipper/index/index.html\">Index</a> along with <a href=\"../scaladoc/1.2.3/io/xskipper/index/IndexFactory.html\">IndexFactory</a>.</li>\n<li>Interface for specifying how to store the metadata in the metadatastore - implementations of <a href=\"../scaladoc/1.2.3/io/xskipper/metadatastore/MetaDataTranslator.html\">MetaDataTranslator</a>.</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#query-evaluation-flow\">Query Evaluation Flow</a> </p>\n<ul class=\"pf-c-list\">\n<li>Interfaces for defining how query expressions are mapped to abstract conditions on metadata - implementations of <a href=\"../scaladoc/1.2.3/io/xskipper/search/filters/MetadataFilter.html\">MetaDataFilter</a> along with <a href=\"../scaladoc/1.2.3/io/xskipper/search/filters/MetadataFilterFactory.html\">MetaDataFilterFactory</a>.</li>\n<li>Interfaces for translating an abstract clause to a specific implementation according to the metadatastore - Implementations of <a href=\"../scaladoc/1.2.3/io/xskipper/metadatastore/ClauseTranslator.html\">ClauseTranslator</a>.</li>\n</ul>\n</li>\n</ul>\n<p>A new plugin can contain one or more of the above implementations.</p>\n<p>This architecture enables the registration of components using multiple packages.</p>\n<h2 id=\"using-existing-plugins\" style=\"position:relative;\"><a href=\"#using-existing-plugins\" aria-label=\"using existing plugins permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using Existing Plugins</h2>\n<p>To use a plugin, load the relevant implementations using the Registration module (<a href=\"../scaladoc/1.2.3/io/xskipper/Registration$.html\">Scala</a>, <a href=\"../pythondoc/1.2.3/index.html#module-xskipper.registration\">Python</a>).<br>\nFor example:</p>\n<p>=== “Python”</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">``` python\nfrom xskipper import Registration\n\nRegistration.addMetadataFilterFactory(spark, &#39;io.xskipper.plugins.regex.filter.RegexValueListMetaDataFilterFactory&#39;)\n# Add IndexFactory\nRegistration.addIndexFactory(spark, &#39;io.xskipper.plugins.regex.index.RegexIndexFactory&#39;)\n# Add MetaDataTranslator\nRegistration.addMetaDataTranslator(spark, &#39;io.xskipper.plugins.regex.parquet.RegexValueListMetaDataTranslator&#39;)\n# Add ClauseTranslator\nRegistration.addClauseTranslator(spark, &#39;io.xskipper.plugins.regex.parquet.RegexValueListClauseTranslator&#39;)\n```</code></pre></div>\n<p>=== “Scala”</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">``` scala\nimport io.xskipper._\nimport io.xskipper.plugins.regex.filter.RegexValueListMetaDataFilterFactory\nimport io.xskipper.plugins.regex.index.RegexIndexFactory\nimport io.xskipper.plugins.regex.parquet.{RegexValueListClauseTranslator, RegexValueListMetaDataTranslator}\n\n// registering the filter factories for user metadataFilters\nRegistration.addIndexFactory(RegexIndexFactory)\nRegistration.addMetadataFilterFactory(RegexValueListMetaDataFilterFactory)\nRegistration.addClauseTranslator(RegexValueListClauseTranslator)\nRegistration.addMetaDataTranslator(RegexValueListMetaDataTranslator)\n```</code></pre></div>\n<p>For the full list of plugins see <a href=\"indexing.md#supported-plugins\">here</a>.</p>\n<br/>\n<p>!!! note\nWhen registering multiple plugins the order of registration for <code class=\"language-text\">IndexFactory</code>, <code class=\"language-text\">MetadataTranslator</code>, and <code class=\"language-text\">ClauseTranslator</code> matters.\nIf two plugins define relevant translations or index creation for the same parameters the first one registered will be used.<br>\nIn general, you should avoid having multiple plugins that behave differently for the same indexes, metadata types or clauses.</p>\n<p>In the following sections we explain how to use the above interfaces in order to create a new plugin.<br>\nThe explanations will use examples from the sample plugin - <a href=\"https://github.com/xskipper-io/xskipper-regex-plugin/blob/master/src/main/scala/io/xskipper/plugins/regex/index/RegexValueListIndex.scala\">xskipper-regex-plugin</a>.</p>\n<p>The regex plugin enables indexing a text column by specifying a list of patterns and saving the matching substrings as a value list.</p>\n<p>For example, consider an application log dataset and one of its objects :</p>\n<div class=\"gatsby-highlight\" data-language=\"csv\"><pre class=\"language-csv\"><code class=\"language-csv\">application_name,log_line\nbatch job,20/12/29 18:04:39 INFO FileSourceStrategy: Pruning directories with:\nbatch job,20/12/29 18:04:40 INFO DAGScheduler: ResultStage 22 (collect at ParquetMetadataHandle.scala:324) finished in 0.011 s</code></pre></div>\n<p>and the regex pattern <code class=\"language-text\">&quot;.* .* .* (.*): .*&quot;</code>.</p>\n<p>When we index using the regex index, the metadata that will be saved is <code class=\"language-text\">List(&quot;FileSourceStrategy&quot;, &quot;DAGScheduler&quot;)</code>.</p>\n<p>The following query will benefit from this index and will skip the above object:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> \n<span class=\"token keyword\">FROM</span> tbl \n<span class=\"token keyword\">WHERE</span> \nregexp_extract<span class=\"token punctuation\">(</span>log_line<span class=\"token punctuation\">,</span> <span class=\"token string\">'.* .* .* (.*): .*'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token string\">'MemoryStore'</span></code></pre></div>\n<h2 id=\"indexing-flow\" style=\"position:relative;\"><a href=\"#indexing-flow\" aria-label=\"indexing flow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Indexing Flow</h2>\n<h3 id=\"define-the-abstract-metadata\" style=\"position:relative;\"><a href=\"#define-the-abstract-metadata\" aria-label=\"define the abstract metadata permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Define the abstract metadata</h3>\n<p><em>Implementation(s) of <a href=\"../scaladoc/1.2.3/io/xskipper/index/metadata/MetadataType.html\">MetaDataType</a></em></p>\n<p>First you need to define the abstract metadata type that will be generated by the index. This type will hold the metadata in memory.<br>\nFor example, the MinMax index metadata type is a tuple of min and max values (see <a href=\"https://github.com/xskipper-io/xskipper/blob/master/src/main/scala/io/xskipper/index/metadata/MinMaxMetaData.scala\">here</a>)</p>\n<p>For the Regex plugin, to store the unique list of matching substrings for a given pattern we use a HashSet of Strings (see <a href=\"https://github.com/xskipper-io/xskipper-regex-plugin/blob/master/src/main/scala/io/xskipper/plugins/regex/index/RegexValueListMetadata.scala\">here</a>).</p>\n<h3 id=\"define-a-new-index\" style=\"position:relative;\"><a href=\"#define-a-new-index\" aria-label=\"define a new index permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Define a new index</h3>\n<p><em>Implementation(s) of <a href=\"../scaladoc/1.2.3/io/xskipper/index/index.html\">Index</a> along with <a href=\"../scaladoc/1.2.3/io/xskipper/index/IndexFactory.html\">IndexFactory</a></em></p>\n<p>Support for new indexes can be achieved by implementing a new class that implements the <a href=\"../scaladoc/1.2.3/io/xskipper/index/index.html\">Index</a> abstract class.<br>\nA new index can use an existing MetaDataType or create its own MetaDataType along with a translation specification to the relevant metadatastore.</p>\n<p>The Index interface enables specifying one of two ways to collect the metadata:</p>\n<ul class=\"pf-c-list\">\n<li>Tree Reduce - in this code path the index processes the object row by row and updates its internal state to reflect the update to the metadata.\nThis mode enables running index creation in parallel for multiple indexes.</li>\n<li>Optimized - using this interface the index processes the entire object DataFrame and generates the metadata.</li>\n</ul>\n<p>For example, both the <a href=\"https://github.com/xskipper-io/xskipper/blob/master/src/main/scala/io/xskipper/index/MinMaxIndex.scala\">MinMaxIndex</a> and the <a href=\"https://github.com/xskipper-io/xskipper-regex-plugin/blob/master/src/main/scala/io/xskipper/plugins/regex/index/RegexValueListIndex.scala\">RegexValueListIndex</a>.\nuse the Tree Reduce mode to accumlate the list of unique matches.</p>\n<p>Along with the Index you need to define an <a href=\"../scaladoc/1.2.3/io/xskipper/index/IndexFactory.html\">IndexFactory</a> -\nthe IndexFactory specifies how to recreate the index instance when loading the index parameters from the metadatastore.\nFor example, see <a href=\"https://github.com/xskipper-io/xskipper-regex-plugin/blob/master/src/main/scala/io/xskipper/plugins/regex/index/RegexIndexFactory.scala\">RegexIndexFactory</a>.</p>\n<h3 id=\"define-translation-for-the-metadata\" style=\"position:relative;\"><a href=\"#define-translation-for-the-metadata\" aria-label=\"define translation for the metadata permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Define translation for the metadata</h3>\n<p><em>Implementation(s) of <a href=\"../scaladoc/1.2.3/io/xskipper/metadatastore/MetaDataTranslator.html\">MetaDataTranslator</a></em></p>\n<p>!!! info\nXskipper uses by default Parquet as the metadatastore.<br>\nThe Parquet metadatastore stores the metadata for the objects as rows in parquet files (for more details see <a href=\"../developer/parquet-metadatastore-spec/\">here</a>).<br>\nThe API enables defining your own metadatastore. Here we focus on storing the metadata in the Parquet metadatastore. Therefore, the translations we cover here relate to the Parquet metadatastore.</p>\n<p>In order to store the abstract metadata defined above in the metadata store we have to specify a suitable translation which will map it to a valid representation for the metadatastore.</p>\n<p>For the Parquet metadatastore we have two options:</p>\n<ul class=\"pf-c-list\">\n<li>Convert the metadata to an internal Spark <a href=\"https://spark.apache.org/docs/latest/api/java/org/apache/spark/sql/Row.html\">Row</a> which will later be saved to Parquet automatically, as Spark supports Parquet out of the box.\nFor example, the MinMax index translates its values to a nested row with <code class=\"language-text\">min</code> and <code class=\"language-text\">max</code> values (see <a href=\"https://github.com/xskipper-io/xskipper/blob/master/src/main/scala/io/xskipper/metadatastore/parquet/ParquetBaseClauseTranslator.scala#L28\">here</a>)</li>\n<li>\n<p>Use a UDT to save the serialized abstract metadata. In some cases translating the metadata to Spark Row is not possible, therefore we save the metadata as a serialized binary.<br>\nTo do so you have 2 options:</p>\n<ul class=\"pf-c-list\">\n<li>Use the default java serialization provided by the parquet metadata store. To do so you need to define the UDT and register it. For example, for bloom filter, we use the following definition to get the default java serialization:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">class</span> BloomFilterMetaDataTypeUDT <span class=\"token keyword\">extends</span> MetadataTypeUDT<span class=\"token punctuation\">[</span>BloomFilterMetaData<span class=\"token punctuation\">]</span></code></pre></div>\n<p>Then register the UDT to Spark using the <a href=\"../scaladoc/1.2.3/org/apache/spark/sql/types/ParquetMetadataStoreUDTRegistration$.html\">ParquetMetadataStoreUDTRegistration</a> object:</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\">ParquetMetadataStoreUDTRegistration<span class=\"token punctuation\">.</span>registerUDT<span class=\"token punctuation\">(</span>classOf<span class=\"token punctuation\">[</span>BloomFilterMetaData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>getName<span class=\"token punctuation\">,</span> classOf<span class=\"token punctuation\">[</span>BloomFilterMetaDataTypeUDT<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>getName<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Note that the bloom filter has the above definition built in so there is no need to register it.</p>\n<p>!!! note\nThe UDT must be defined and registered in any program that uses the index.<br>\nA recommended pattern is to define and register the UDT in the <a href=\"#define-translation-for-the-clause\">Clause Translator</a> object where you also define the Clause Translation logic.<br>\nThis object will be loaded when <a href=\"#using-existing-plugins\">registering</a> the Clause Translator.</p>\n<ul class=\"pf-c-list\">\n<li>Define your own UDT with custom serialization logic - similar to the above only this time you implement your own UDT.<br>\nSee the <a href=\"https://github.com/xskipper-io/xskipper/blob/master/src/main/scala/io/xskipper/metadatastore/parquet/ParquetMetadataTypeUDT.scala\"><code class=\"language-text\">MetadataTypeUDT</code></a> class for a reference.</li>\n</ul>\n</li>\n</ul>\n<p>For the regex plugin we use the first option and translate the list of values to an array of values for storing in Parquet format (see <a href=\"https://github.com/xskipper-io/xskipper-regex-plugin/blob/master/src/main/scala/io/xskipper/plugins/regex/parquet/RegexValueListMetaDataTranslator.scala\">here</a>).</p>\n<h2 id=\"query-evaluation-flow\" style=\"position:relative;\"><a href=\"#query-evaluation-flow\" aria-label=\"query evaluation flow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Query Evaluation Flow</h2>\n<h3 id=\"define-the-abstract-clause\" style=\"position:relative;\"><a href=\"#define-the-abstract-clause\" aria-label=\"define the abstract clause permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Define the abstract clause</h3>\n<p><em>Implementations of <a href=\"../scaladoc/1.2.3/io/xskipper/search/clause/Clause.html\">Clause</a></em></p>\n<p>First, you need to define the abstract clause that will be created by the Filter.<br>\nThe Clause specifices an abstract condition which was deduced from the query and should operate on the metadata in order to determine the relevant objects.\nEach Clause is then translated to an explicit implementation according to the metadatastore type.   </p>\n<p>For example, for the MinMax index we define a <a href=\"https://github.com/xskipper-io/xskipper/blob/master/src/main/scala/io/xskipper/search/clause/MinMaxClause.scala\">MinMaxClause</a> which follows the logic that was presented <a href=\"../concepts/query-evaluation-flow.md#clause\">here</a>.</p>\n<p>For the Regex Plugin we use a Clause which holds the required matching patterns from the query (see <a href=\"https://github.com/xskipper-io/xskipper-regex-plugin/blob/master/src/main/scala/io/xskipper/plugins/regex/clause/RegexValueListClause.scala\">here</a>).</p>\n<h3 id=\"define-a-new-filter\" style=\"position:relative;\"><a href=\"#define-a-new-filter\" aria-label=\"define a new filter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Define a new filter</h3>\n<p><em>Implementation(s) of <a href=\"../scaladoc/1.2.3/io/xskipper/search/filters/MetadataFilter.html\">MetaDataFilter</a> along with <a href=\"../scaladoc/1.2.3/io/xskipper/search/filters/MetadataFilterFactory.html\">MetaDataFilterFactory</a></em></p>\n<p>The filter processes the query tree and labels it with clauses. In most cases we would like to map expressions to clauses.\nTherefore, xskipper provides a basic implementation of a filter called <a href=\"https://github.com/xskipper-io/xskipper/blob/master/src/main/scala/io/xskipper/search/filters/MetadataFilter.scala\">BaseMetadataFilter</a>\nwhich processes the query tree automatically for AND and OR operators, leaving the user to handle only the remaining expressions. Implementations which extend the <a href=\"https://github.com/xskipper-io/xskipper/blob/master/src/main/scala/io/xskipper/search/filters/MetadataFilter.scala\">BaseMetadataFilter</a> need only specify how expressions are mapped to clauses.<br>\nFor example,  <a href=\"https://github.com/xskipper-io/xskipper-regex-plugin/blob/master/src/main/scala/io/xskipper/plugins/regex/filter/RegexValueListFilter.scala\">RegexValueListFilter</a> and <a href=\"https://github.com/xskipper-io/xskipper/blob/master/src/main/scala/io/xskipper/search/filters/MinMaxFilter.scala\">MinMaxFilter</a> map the query expressions according to the logic presented <a href=\"../concepts/query-evaluation-flow.md#filter\">here</a>.</p>\n<p>A more advanced filter can process the entire tree by implementing the <code class=\"language-text\">MetaDataFilter</code> class without using the <code class=\"language-text\">BaseMetadataFilter</code>.</p>\n<p>Along with a Filter you need to define a <a href=\"../scaladoc/1.2.3/io/xskipper/search/filters/MetadataFilterFactory.html\">MetadataFilterFactory</a>. The MetadataFilterFactory specifies which filters should run given the available indexes.\nFor example, see the <a href=\"https://github.com/xskipper-io/xskipper-regex-plugin/blob/master/src/main/scala/io/xskipper/plugins/regex/index/RegexIndexFactory.scala\">RegexIndexFactory</a>.</p>\n<h3 id=\"define-translation-for-the-clause\" style=\"position:relative;\"><a href=\"#define-translation-for-the-clause\" aria-label=\"define translation for the clause permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Define translation for the clause</h3>\n<p><em>Implementations of <a href=\"../scaladoc/1.2.3/io/xskipper/metadatastore/ClauseTranslator.html\">ClauseTranslator</a></em></p>\n<p>!!! info\nXskipper uses Parquet as the metadatastore by default.<br>\nThe Parquet metadatastore stores the metadata for the objects as rows in parquet files (for more details see <a href=\"developer/parquet-metadatastore-spec.md\">here</a>).<br>\nSpark is used as the engine to run the abstract clauses on the metadata.<br>\nThe API enables defining your own metadatastore. Here we focus on the metadata in the Parquet metadatastore. Therefore, the translations are relevant to the Parquet metadatastore.</p>\n<p>In order to process a clause, the abstract clause defined above needs to be translated to a form that is executable by the metadatastore.</p>\n<p>For the Parquet metadatastore we have 2 options:</p>\n<ul class=\"pf-c-list\">\n<li>Translate the Clause to a native Spark operation - this is useful when you have a built-in expression in Spark that can process the metadata. For example, for the MinMax index we use Spark’s built-in inequality operators (>, &#x3C;, >=, &#x3C;=) to translate the abstract clause (see <a href=\"https://github.com/xskipper-io/xskipper/blob/0b430e9df3abaec2ee8ec530c702b6534c9f751f/src/main/scala/io/xskipper/metadatastore/parquet/ParquetBaseClauseTranslator.scala#L56\">here</a>).</li>\n<li>Use a UDF that will process the metadata - this is useful when the metadata is saved by serializing the abstract metadata type\nor when there is no built-in operation that implements the logic needed in order to process the metadata.<br>\nFor example, for the BloomFilter index which we serializes its metadata, we use a UDF to check whether the given value exists in the metadata or not (see <a href=\"https://github.com/xskipper-io/xskipper/blob/master/src/main/scala/io/xskipper/metadatastore/parquet/ParquetBaseClauseTranslator.scala\">here</a>).</li>\n</ul>\n<p>For the Regex Plugin we translate the clause to use Spark’s <code class=\"language-text\">arrays_overlap</code> and <code class=\"language-text\">array_except</code> functions in order to check if the values in the clause exist in the metadata (see <a href=\"https://github.com/xskipper-io/xskipper-regex-plugin/blob/master/src/main/scala/io/xskipper/plugins/regex/parquet/RegexValueListClauseTranslator.scala\">here</a>).</p>","fields":{"srcLink":"https://github.com/xskipper-io/xskipper/blob/master/site/docs/api/creating-new-plugin.md"},"frontmatter":{"title":"","description":null,"extraClasses":null}}},"pageContext":{"id":"cb1a965a-65f6-5f2b-b3bd-62a8b8207828"}},"staticQueryHashes":["117426894","3000541721","3606484676","533861647"]}